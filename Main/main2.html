<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive PM2.5 Map Generator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- General Layout Settings --- */
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Prevent scrolling on the body */
        }

        body {
            font-family: 'Sarabun', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        main {
            display: flex;
            gap: 20px;
            width: 95vw;
            height: 90vh;
            max-width: 1600px;
        }

        /* --- Map Area --- */
        #map-container {
            flex-grow: 1; /* Allow map to take available space */
            height: 100%;
            background-image: url('My_poster.jpg'); /* Placeholder for your map */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: relative;
            cursor: crosshair;
            border: 2px solid #ccc;
            border-radius: 8px;
        }

        .marker {
            width: 18px;
            height: 18px;
            background-color: rgba(255, 0, 0, 0.8);
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%); /* Center the marker */
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        /* --- Callout Lines and Labels --- */
        .callout-line {
            background-color: #D92121;
            position: absolute;
            pointer-events: none;
        }

        .callout-label {
            position: absolute;
            display: flex;
            align-items: center;
            background-color: white;
            padding: 5px 10px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            pointer-events: none;
            gap: 8px;
            white-space: nowrap;
            transform: translateY(-50%); /* Vertically center the label */
        }

        .rank-circle {
            width: 30px;
            height: 30px;
            background-color: #D92121;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 700;
            font-size: 18px;
            flex-shrink: 0;
        }

        .rank-name {
            font-size: 16px;
            font-weight: 700;
            color: #333;
        }

        /* --- Sidebar for Data Entry --- */
        #sidebar {
            width: 350px;
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
            height: 100%;
            overflow-y: auto; /* Allow sidebar to scroll if content overflows */
            box-sizing: border-box;
        }
        
        #sidebar h2 { margin-top: 0; }
        #sidebar p { color: #666; font-size: 14px; }
        #positions-list { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }

        .position-entry {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .position-entry label {
            font-weight: 700;
            width: 100px;
        }

        .position-entry input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
        }

        /* --- Control Buttons --- */
        .controls { margin-top: 30px; display: flex; flex-direction: column; gap: 10px; }
        
        button {
            font-family: 'Sarabun', sans-serif;
            font-size: 16px;
            padding: 12px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: 700;
            transition: background-color 0.2s, transform 0.1s;
        }
        button:active {
            transform: scale(0.98);
        }

        #generate-btn { background-color: #28a745; }
        #generate-btn:hover { background-color: #218838; }

        #reset-btn { background-color: #dc3545; }
        #reset-btn:hover { background-color: #c82333; }

    </style>
</head>
<body>

    <main>
        <div id="map-container"></div>
        <div id="sidebar">
            <h2>กำหนดจุดตรวจวัด</h2>
            <p>คลิกบนแผนที่ด้านซ้ายเพื่อเพิ่มจุดตรวจวัดใหม่</p>
            <div id="positions-list"></div>
            <div class="controls">
                <button id="generate-btn">สร้างรายงาน 5 อันดับสูงสุด</button>
                <button id="reset-btn">รีเซ็ตทั้งหมด</button>
            </div>
        </div>
    </main>

    <script>
        // --- Main variables ---
        const mapContainer = document.getElementById('map-container');
        const positionsList = document.getElementById('positions-list');
        const generateBtn = document.getElementById('generate-btn');
        const resetBtn = document.getElementById('reset-btn');

        let positions = []; // Array to store all point data
        let positionCounter = 1;

        // --- Function: Clear old lines and labels ---
        function clearVisualizations() {
            const oldVisuals = document.querySelectorAll('.callout-line, .callout-label');
            oldVisuals.forEach(el => el.remove());
        }

        // --- Function: Add a new point on map click ---
        mapContainer.addEventListener('click', (event) => {
            const rect = mapContainer.getBoundingClientRect();
            // Calculate coordinates relative to the map container's dimensions
            const x = (event.clientX - rect.left);
            const y = (event.clientY - rect.top);
            
            // Prevent adding points outside the visible map area
            if (x < 0 || x > rect.width || y < 0 || y > rect.height) return;

            // 1. Create a marker on the map
            const marker = document.createElement('div');
            marker.className = 'marker';
            marker.style.left = `${x}px`;
            marker.style.top = `${y}px`;
            mapContainer.appendChild(marker);

            // 2. Create a data entry field in the sidebar
            const positionName = `จุดที่ ${positionCounter}`;
            const entry = document.createElement('div');
            entry.className = 'position-entry';
            entry.innerHTML = `
                <label for="pos-${positionCounter}">${positionName}:</label>
                <input type="number" id="pos-${positionCounter}" placeholder="กรอกค่าฝุ่น">
            `;
            positionsList.appendChild(entry);
            const inputElement = entry.querySelector('input');

            // 3. Store the point's data
            positions.push({
                id: positionCounter,
                name: positionName,
                x: x,
                y: y,
                value: 0,
                markerElement: marker,
                inputElement: inputElement
            });
            positionCounter++;
        });

        // --- Function: Generate the report ---
        generateBtn.addEventListener('click', () => {
            clearVisualizations();

            // 1. Update values from input fields
            positions.forEach(pos => {
                const val = parseFloat(pos.inputElement.value);
                pos.value = isNaN(val) ? 0 : val;
            });

            // 2. Sort data by value and get the top 5
            const top5 = [...positions]
                .sort((a, b) => b.value - a.value)
                .slice(0, 5)
                .filter(p => p.value > 0); // Only visualize points with a value

            const mapWidth = mapContainer.clientWidth;
            const labelHeight = 45; // Height of each label + padding
            const horizontalOffset = 100; // How far the line extends horizontally
            
            // Separate points into left and right groups to manage them independently
            const leftSidePoints = top5.filter(p => p.x < mapWidth / 2).sort((a,b) => a.y - b.y);
            const rightSidePoints = top5.filter(p => p.x >= mapWidth / 2).sort((a,b) => a.y - b.y);

            let lastLeftY = -Infinity;
            let lastRightY = -Infinity;

            // Function to draw a single callout, handling positioning and overlap
            const drawCallout = (pos, index, isRightSide) => {
                const rank = top5.findIndex(p => p.id === pos.id) + 1;

                // Determine the direction and starting endX
                const direction = isRightSide ? -1 : 1; // -1 for left, 1 for right
                const startX = pos.x;
                const endX = startX + (horizontalOffset * direction);

                // --- Overlap Prevention Logic ---
                let lastY = isRightSide ? lastRightY : lastLeftY;
                let endY = Math.max(pos.y, lastY + labelHeight);
                
                if (isRightSide) {
                    lastRightY = endY;
                } else {
                    lastLeftY = endY;
                }

                // --- Create Visual Elements ---

                // Horizontal Line
                const lineH = document.createElement('div');
                lineH.className = 'callout-line';
                lineH.style.left = `${Math.min(startX, endX)}px`;
                lineH.style.top = `${pos.y - 1}px`;
                lineH.style.width = `${Math.abs(endX - startX)}px`;
                lineH.style.height = '2px';

                // Vertical Line
                const lineV = document.createElement('div');
                lineV.className = 'callout-line';
                lineV.style.left = `${endX - 1}px`;
                lineV.style.top = `${Math.min(pos.y, endY)}px`;
                lineV.style.width = '2px';
                lineV.style.height = `${Math.abs(pos.y - endY) + 2}px`;

                // Label
                const label = document.createElement('div');
                label.className = 'callout-label';
                label.style.top = `${endY}px`;
                label.innerHTML = `
                    <div class="rank-circle">${rank}</div>
                    <div class="rank-name">${pos.name} (${pos.value})</div>
                `;

                // Position label based on direction
                if (direction === 1) { // Points right
                    label.style.left = `${endX + 5}px`;
                } else { // Points left
                    // Must append to measure width first
                    document.body.appendChild(label);
                    const labelWidth = label.getBoundingClientRect().width;
                    label.style.left = `${endX - 5 - labelWidth}px`;
                    mapContainer.appendChild(label);
                }
                
                mapContainer.appendChild(lineH);
                mapContainer.appendChild(lineV);
                if(label.parentElement !== mapContainer) mapContainer.appendChild(label);
            };

            // Draw callouts for each group
            leftSidePoints.forEach((pos, index) => drawCallout(pos, index, false));
            rightSidePoints.forEach((pos, index) => drawCallout(pos, index, true));

        });
        
        // --- Function: Reset everything ---
        resetBtn.addEventListener('click', () => {
            clearVisualizations();
            // Remove all markers
            const allMarkers = document.querySelectorAll('.marker');
            allMarkers.forEach(m => m.remove());
            // Clear all input fields
            positionsList.innerHTML = '';
            // Reset variables
            positions = [];
            positionCounter = 1;
        });
    </script>
</body>
</html>
